\section{Implementation details}\label{sec:implementation_details}

\subsection{Structure of the simulations}
The simulations can be considered as composed of four different parts.
\subsubsection{Initialization}
The parachutes are initially randomly located around a desired point. They have to be properly spaced since collision avoidance during the navigation is ensured only if they don't collide in the initial step, as it is expected that real parachutes are delivered reasonably far from each other. \\
At the beginning of the simulation, each parachute is aware of the number of agents in the swarm; it knows its position with a small uncertainty, but they do not know the location of all the other agents (so they assign a random location reasonably far from themselves with a high uncertainty to them).
\subsubsection{Free falling}
After the launch, the parachutes begin to accelerate downwards with closed sail and zero inputs. Only the wind disturbance can act on their position.
\subsubsection{Target convergence and controlled movement}
When the terminal velocity is reached, the parachutes open and begin to communicate with each other to do the Voronoi tessellation and compute the input necessary to reach the target.
\subsubsection{Landing}
When the agents arrive reasonably close to the ground, they start to decelerate by breaking to reach the minimum vertical velocity, arriving more gently.

\subsection{Localization}
Following the hypothesis mentioned in the \autoref{subsec:solution_localization}, the measurement error, GPS tracking and wind noises/errors have been set with zero mean and Gaussian, using a random variance generator. The values of the standard deviations have already been discussed in the section \ref{communication}.\\
While the dynamics consider the wind effect, in the predictions step of the KF, it is supposed to be unknown; the parachute cannot measure the direction of the wind and its module. However, the variance of the wind disturbance is considered to be known, and it is included in the update of the covariance matrix of the estimated position (\ref{covariance}). In the equation are involved the model matrices $A$, $B$ and $G$ and the covariance matrix of the wind disturbance $L$, while the wind effect is set to zero.
\begin{gather}
    \label{prediction}
    x_{est} = Ax_{est}+Bu+G\begin{bmatrix}
        0 & 0 & 0 & \bar{v}_z
    \end{bmatrix}^T\\
    \label{covariance}
    P_{est} = AP_{est}A^T+BQB^T+GLG^T
\end{gather}
The same holds for the non-linear model, with the difference of having an EKF with linearised model matrices.\\
On top of what was already presented in \autoref{subsec:solution_localization}, another feature that has to be taken into account is the possibility for the agent \textit{i} to see \textit{j} at a one-time step but not in the following. When this happens, \textit{i} assumes that \textit{j} is still using the input of the last communication and so uses it to propagate the dynamic, while it increases the uncertainty. This update continues until when \textit{j} is seen again or the uncertainty on \textit{j} grows above a pre-defined threshold. Note that this propagation requires that the applied inputs are exchanged during the data communication.

\subsection{Local estimation of the global centroid}
Each agent performs a local estimation of the global centroid by a weighted mean of the localisation of the others by the uncertainty on them. This implies that if a parachute does not know the position of any other (equivalent to knowing the location with high uncertainty), then it assumes that the centroid of the storm is itself. So, it applies the high-level control law only to itself. 

\subsection{Collision avoidance}
Without losing generality, let us assume that the agent \textit{i} performs the tessellation, while \textit{j} is a different agent in the storm. Chute \textit{i} has location $p_i=\left[x_i, y_i, z_i\right]^T$, a physical dimension inscribed in a circle of radius $\delta_i$ in the horizontal plane and $\delta_{z,i}$ in the vertical one, knows its position and the one of j with an uncertainty of respectively
{\small
\begin{equation*}
  diag(P_i^i)=\{{ \sigma_{x,i}^{i}}^{2}, {\sigma_{y,i}^i}^{2}, {\sigma_{z,i}^i}^{2}\}, \,  diag(P_j^i)=\{{\sigma_{x,j}^i}^{2}, {\sigma_{y,j}^i}^{2}, {\sigma_{z,j}^i}^{2}\}
\end{equation*}
}

where $P_i^i$ and $P_j^i$ are the covariance matrices of the localization error of \textit{i} and \textit{j} respectively, 
and has a maximum linear velocity of $v_{max,i} \ \left[\si{\meter\per\second}\right]$ in the horizontal plane and $v_{max,zi} \ \left[\si{\meter\per\second}\right]$ in the vertical (such that the maximum displacement in one-time step is $s_i=v_{max,i}dt \ \left[\si{\meter}\right]$ and $s_{z,i}=v_{max,zi}dt \ \left[\si{\meter}\right]$ respectively). 

\subsubsection{Uncertainty in the localisation} 
  The uncertainty in the self-localisation is taken into account by increasing the dimension of the agent $\delta_i$ as:
    \begin{equation}
        \tilde{\delta_i}=\delta_i + \kappa \max \left\{\sigma_{x,i}^i, \sigma_{y,i}^i \right\}
        \label{eq:expand_dimension}
    \end{equation}
    where $\kappa$ is a coverage factor.\\
    The uncertainty on the position of \textit{j} is considered by projecting its location as:
    \begin{equation}
        \tilde{p_j} = p_j + \min\left\{ \lVert p_i-p_j \lVert, \kappa \max\left\{\sigma_{x,j}^i, \sigma_{y,j}^i\right\}\right\}\frac{p_i - p_j}{\left\lVert p_i - p_j \right\lVert}
    \end{equation}
   The min function is necessary to avoid the new agent \textit{j} position falling behind the agent \textit{i} itself.   
    
    \subsubsection{Finite dimension and discrete-time dynamic}
    The finite dimension is taken into the picture by redefining the Voronoi area as follows:
    \begin{gather}
        \tilde{\mathcal{V}_i} =
        \begin{cases} 
            \left\{ q \in \mathcal{Q} \lvert \left\lVert q-p_i \right\rVert \leq \left\lVert q-\tilde{p_j} \right\rVert\right\}  & \Delta_i \leq \frac{\left\lVert p_i - \tilde{p_j} \right\lVert}{2} \\
            \left\{ q \in \mathcal{Q} \lvert \left\lVert q-p_i \right\rVert \leq \left\lVert q-\hat{p_j} \right\rVert\right\} & \text{otherwise} 
        \end{cases} 
        \label{eq:Voronoi_finite_dimensions}
    \end{gather}
    where $\Delta_i = s_i + \delta_{i}$ and
    \begin{equation}
        \hat{p_j} = \tilde{p_j} + \text{min}\{2 \delta_i, \left\lVert p_i - \tilde{p_j} \right\lVert\}\frac{p_i - \tilde{p_j}}{\left\lVert p_i - \tilde{p_j} \right\lVert}
    \end{equation}
    Moreover, in the case when the centroid can reach the cell limit in one time step, the sensing range $R_s$ has to be reduced, implying that the maximum Voronoi cell is shrunk at least of the dimension of the chute:
    \begin{equation}
        \tilde{R_s} = 
        \begin{cases}
            R_s & \text{if } s_i + \delta_i > R_s\\
            \max\{0, R_s - \tilde{\delta_i}\} & \text{otherwise}
        \end{cases}
        \label{eq:rs}
    \end{equation}\\
    Note that this approach requires only the knowledge of the dimension of the chute performing the tessellation.

   \subsubsection{Decentralisation of the algorithm} 
    In the decentralised implementation of the algorithm, it is possible that the chute is not aware of the location of all the others in the storm, so it has to care only about the parachutes in a region of space around it. This subset of agents is called \textit{neighbour set}, and it is defined as:
    \begin{equation}
            \mathcal{N}_i = \left\{\hat{p_j} \in \mathbb{R}^2 \lvert \left\lVert p_i-\hat{p_j} \right\rVert < R_{c} \right\}
            \label{eq:neighbour_set}
        \end{equation}
    With this consideration in mind, the agent's cell is given by:
        \begin{equation}
            \hat{\mathcal{V}_i}=\left\{\tilde{\mathcal{V}_i} \cap \bar{\mathcal{C}}_{i, \tilde{R_s}} \right\}
        \end{equation}
    where $\bar{\mathcal{C}}_{i, \tilde{R_s}}$ is the closure of the circle with radius $\tilde{R_s}$.  
    
    \subsubsection{Extension to the 3D case}  
    It is assumed that the agent performing the tessellation can detect the presence of the others even when they are above and below it in a range defined by $R_{cv}$ (sensing range in the vertical direction). In particular, when another agent is detected within this range, it is included in the neighbour set as:
    \begin{gather}
        \tilde{\mathcal{N}_i} = \{p_j \in \mathcal{N}_{i} \lvert \lvert \Delta_z \lvert < R_{cv} + \kappa \sigma_z^i
        + \frac{\Delta_z}{\lVert \Delta_z \lVert }\Delta s_z\} %\notag
        \label{eq:neighbour_set_Voronoi}
    \end{gather}
    where $\Delta_z=z_i - z_j$ is the height difference, $\Delta s_z = s_{z, i} - s_{z,j}$ is the difference between the maximum vertical displacements, and $\sigma_z^i=\sigma_{z,i}^i + \sigma_{z, j}^i$.\\
    Since the parachute models have only a unidirectional actuation in the vertical direction (i.e., they can only brake their fall and not go upwards), the only limit necessary to identify the z-axis tessellation is the lower. This can be done by:
    \begin{equation}
    {\scriptsize
        \mathcal{Z}_i = 
        \begin{cases}
            \left\{q\in \mathcal{Q} \lvert 0 \le z_i-z_q \le \Delta z - \delta_z - \kappa \sigma_z^i \right\}& \Delta_z \ge 0 \wedge i \in \tilde{\mathcal{N}_i} \\
            \left\{q \in \mathcal{Q} \lvert 0 \le z_i-z_q
            \le R_{sv} + \kappa \sigma_{z, i}^i \right\} & otherwise
        \end{cases}   } 
    \end{equation}
    where $z_q$ is the generic point along the z-axis.
   
\subsection{High-level motion control}\label{sec:details_high_level}
\subsubsection{Weights for the LQR}
The only parameters to be set in the LQR control are the weight matrices $S$ and $R$. By increasing the state matrix, the algorithm reduces the error between the actual state and the desired one, while increasing the input matrix minimises the input. They are usually competing objectives. Since the parachute inputs will be saturated in the low-level control, there is no interest in using a big input matrix. At the same time, it is essential to have a good performance of the states to reduce the final distance between the global centroid and the target.
\subsubsection{Same control for all the chutes}
This is a simple control low because the agent applies the same input computed for the fake parachute representing the global centroid.
\subsubsection{Inverse kinematics}
 Regarding the inverse kinematics, the postural task asks to make the single agents converge towards the global centroid to reduce the root mean square of the agents' distance from the global centroid and, eventually, from the target, thanks to the main task. The importance of this choice is explained further in the Results section. When using the postural task, the weighting value is set such that the closer the global centroid is to the target, the more importance is given to letting the single parachute converge toward the global centroid, with exponential behaviour. The pseudo-code of the inverse kinematics algorithm is presented in the Algorithm \ref{algorithm}.

\begin{algorithm}[hb]
 {\footnotesize
\caption{Numerical IK}\label{NIK}
    \begin{itemize}
    \item Find centroid error position $e_c$
    \item Find parachute error position $e_x$
    \item Find total error position $e=[e_c;e_x]$
    \item Find jacobian matrix $J$
    \item Initialize line search factor $\alpha=1$
    \item Initialize weighting factor $w$
    \end{itemize}
    \mywhile \ $|e_c|^2 \ge 0.5 \And |e_x|^2 \ge 0.1$
    \begin{enumerate}
        \item $\Delta x = (J^TJ+w^2I)^{-1}(J^Te_c+w^2e_x)$
        \item $x_{test} = x + \alpha \Delta x$
        \item $x = x_{test}$
        \item $e = e'$
    \end{enumerate}
    \myendwhile
    \label{algorithm}
    }
\end{algorithm}

\subsubsection{Managing of emergency case}
As said before, the low-level control is performed after dividing the plane where the parachute moves with a Voronoi tessellation, considering all the agents in a surrounding space of the considered one. Even though it is, in principle, permissible for two agents having the same position in the xy plane and different heights, there are some situations in which this can create problems. For example, when an agent sees many others around it, its Voronoi cell may be reduced to a point because of having considered uncertainties and finite dimensions. If, in this case, it localises other agents below it with an xy location reasonably close to its own, then it will not be able to move to avoid the collision. To solve this issue, the \textit{emergency control} tries to move the falling agent as far as possible from the new see ones. This is done by not considering the uncertainties in the tessellation (i.e. enlarging the Voronoi cell as much as possible) and moving in the opposite directions with respect to the sum of the vectors connecting itself and the considered ones.
\subsection{Low-level motion control}
While the algorithm calculates the value of the LQR gain, the values of the proportional gains of the low-level control have to be chosen. For the linear model gain of the equation (\ref{eq:proportional}), it is important to choose a value such that there is no risk of overshooting the target. This condition is avoided if the inequality (\ref{gain}) holds: in one step, the displacement given by the controller must not be greater than the target distance.\\
\begin{equation}
  k_p\left(p_i - C_{\mathcal{V}_i}\right)dt \le \left(p_i - C_{\mathcal{V}_i}\right) \Rightarrow k_p \le 1/dt
  \label{gain}
\end{equation}
Regarding the non-linear model, on the other hand, the gain for the forward velocity is set to one, and the gain for the angular velocity is set such that in one time step, it is less than the maximum one (\ref{angular_vel}) allowed by (\ref{eq:control_law}).
\begin{equation}
  \label{angular_vel}
  k_{\omega} = \omega_{max}/\pi
\end{equation}
Once the input is calculated and the error is summed to them to account for their errors, they are saturated to consider the actual performances. Even though the real actuator has not been identified, the errors' standard deviation of the actuators is set as 10\% of the maximum permissible input, with a coverage factor of 3 (i.e. 99.73\% of probability).

\subsection{Conclusion of the simulation}
When an agent touches the ground, it cannot move any more, and its control input is set to zero. However, the GPS signal continues to arrive, and the parachute continues communicating with the other agents and sending its position.