\section{Implementation details}\label{sec:implementation_details}

\textcolor{blue}{\subsection{Structure of the simulations}
The simulations can be considered as composed by four different parts.
\subsubsection{Initialization}
The parachutes are initially randomly located around a desired point. They have to be properly spaced since the collision avoidance during the navigation is ensured only if they don't collide in the initial step,a nd because it is expected that real parachutes are delivered reasonably far from each others. \\
At the beginning of the simulation each parachute is aware of the number of agents in the swarm, it knows its own position with a small uncertainty, it does not know the position of all the other agents (and so it assigns a high uncertainty to them).
\subsubsection{Free falling}
The parachute after the launch begin to accelerate until their terminal velocity. In this section, the parachutes are closed and the input is set to zero. Only the wind disturbance can act on their position.
\subsubsection{Target convergence and controlled movement}
When the terminal velocity is reached the parachutes open and they begin to communicate each other, do the Voronoi tessellation and compute the input.
\subsubsection{Landing}
When the agents arrive at 1/10 of the initial height, they start to decelerate by breaking to reach the minimum vertical velocity, not to arrive at the ground too fast.}

\subsection{Localization}
Following the hypothesis mentioned in the \autoref{subsec:solution_localization}, the measurement error, GPS tracking and wind noises/errors have been set with zero mean and Gaussian, using a random variance generator. The values of the standard deviations have already been discussed in the section \ref{communication}.\\
While the dynamics take into account the wind effect, in the predictions step of the Kalman Filter it is supposed to be unknown; the parachute cannot in fact measure the direction of the wind and its module. However, the variance of the wind disturbance is supposed to be known, and it is included in the update of the covariance matrix of the estimated position (\ref{covariance}). In the equation are involved the model matrices $A$, $B$ and $G$ and the covariance matrix of the wind disturbance $L$, while the wind effect is set to zero.
\begin{gather}
    \label{prediction}
    x_{est} = Ax_{est}+Bu+G\begin{bmatrix}
        0 & 0 & 0 & \bar{v}_z
    \end{bmatrix}^T\\
    \label{covariance}
    P_{est} = AP_{est}A^T+BQB^T+GLG^T
\end{gather}
The same holds for the non-linear model, with the difference of having an EKF with linearized model matrices.\\
On top on what was already presented in \autoref{subsec:solution_localization}, another feature that have to be taken into account is the possibility for the agent \textit{i} to see \textit{j} at one time step but not in the following. When this happens, \textit{i} assumes that \textit{j} is still using the input of the last communication and so uses it to propagate the dynamic, while it increases the uncertainty. This update goes on up until when \textit{j} is seen again or the uncertainty on \textit{j} grows above a pre-defined threshold. Note that this propagation requires that during the data communication also the applied inputs are exchanged.

\subsection{Local estimation of the global centroid}
Each agent performs a local estimation of the global centroid by a weighted mean of the localization of the others by the uncertainty on them. This implies that if a parachute does not know the position of any other (which is equivalent that it knows the positions with high uncertainty), then it assumes that the centroid of the storm is itself and so it applies the hijh level control law only on itself. 

\subsection{Collision avoidance}
Without losing generality, let us assume that the agent \textit{i} is the one performing the tessellation, while \textit{j} is a different agent in the storm. Chute \textit{i} has location $p_i=\left[x_i, y_i, z_i\right]^T$, a physical dimension inscribed in a circle of radius $\delta_i$ in the horizontal plane and $\delta_{z,i}$ in the vertical one, knows its own position and the one of j with an uncertainty of respectively
{\small
\begin{equation*}
  diag(P_i^i)=\{{ \sigma_{x,i}^{i}}^{2}, {\sigma_{y,i}^i}^{2}, {\sigma_{z,i}^i}^{2}\}, \,  diag(P_j^i)=\{{\sigma_{x,j}^i}^{2}, {\sigma_{y,j}^i}^{2}, {\sigma_{z,j}^i}^{2}\}
\end{equation*}
}

where $P_i^i$ and $P_j^i$ are the covariance matrices of the localization error of \textit{i} and \textit{j} respectively, 
and has a maximum linear velocity of $v_{max,i} \ \left[\si{\meter\per\second}\right]$ in the horizontal plane and $v_{max,zi} \ \left[\si{\meter\per\second}\right]$ in the vertical (such that the maximum displacement in one time step is $s_i=v_{MAX,i}dt \ \left[\si{\meter}\right]$ and $s_{z,i}=v_{MAX,zi}dt \ \left[\si{\meter}\right]$ respectively) . 

\subsubsection{Uncertainty in the localization} 
  The uncertainty in the self localization is taken into account by increasing the dimension of the agent $\delta_i$ as:
    \begin{equation}
        \tilde{\delta_i}=\delta_i + \kappa \max \left\{\sigma_{x,i}^i, \sigma_{y,i}^i \right\}
        \label{eq:expand_dimension}
    \end{equation}
    where $\kappa$ is a coverage factor.\\
    The uncertainty on the position of \textit{j} is considered by projecting its location as:
    \begin{equation}
        \tilde{p_j} = p_j + \min\left\{ \lVert p_i-p_j \lVert, \kappa \max\left\{\sigma_{x,j}^i, \sigma_{y,j}^i\right\}\right\}\frac{p_i - p_j}{\left\lVert p_i - p_j \right\lVert}
    \end{equation}
   The use of the min function is necessary to avoid that the new agent \textit{j} position goes behind the agent \textit{i} itself.   
    
    \subsubsection{Finite dimension and discrete time dynamic}
    The finite dimension is taken into the picture by redefining the voronoi area as follows:
    \begin{gather}
        \tilde{\mathcal{V}_i} =
        \begin{cases} 
            \left\{ q \in \mathcal{Q} \lvert \left\lVert q-p_i \right\rVert \leq \left\lVert q-\tilde{p_j} \right\rVert\right\}  & \Delta_i \leq \frac{\left\lVert p_i - \tilde{p_j} \right\lVert}{2} \\
            \left\{ q \in \mathcal{Q} \lvert \left\lVert q-p_i \right\rVert \leq \left\lVert q-\hat{p_j} \right\rVert\right\} & \text{otherwise} 
        \end{cases} 
        \label{eq:voronoi_finite_dimensions}
    \end{gather}
    where $\Delta_i = s_i + \delta_{i}$ and
    \begin{equation}
        \hat{p_j} = \tilde{p_j} + \text{min}\{2 \delta_i, \left\lVert p_i - \tilde{p_j} \right\lVert\}\frac{p_i - \tilde{p_j}}{\left\lVert p_i - \tilde{p_j} \right\lVert}
    \end{equation}
    Moreover in the case when the centroid can reach the cell limit in one time step, the sensing range $R_s$ has to be reduced implying that the maximum voronoi cell is shrinked at least of the dimension of the chute:
    \begin{equation}
        \tilde{R_s} = 
        \begin{cases}
            R_s & \text{if } s_i + \delta_i > R_s\\
            R_s - \tilde{\delta_i} & \text{otherewise}
        \end{cases}
        \label{eq:rs}
    \end{equation}\\
    Note that this approach requires only the knowledge of the dimension of the chute performing the tessellation.

   \subsubsection{Decentralization of the algorithm} 
    In the decentralized implementation of the algorithm, it is possible that the chute is not aware of the location of all the others in the storm and so it has to care only about the parachutes that are in a region of space around it. This subset of agents is called \textit{neighbour set} and it is defined as:
    \begin{equation}
            \mathcal{N}_i = \left\{\hat{p_j} \in \mathbb{R}^2 \lvert \left\lVert p_i-\hat{p_j} \right\rVert < \tilde{R_{c,ij}} \right\}
            \label{eq:neighbour_set}
        \end{equation}
    with $\tilde{R_{c,ij}} = R_c + \kappa \left(\text{max}\left\{\sigma_{x,i}^i, \sigma_{y,i}^i\right\} + \text{max}\left\{\sigma_{x,j}^i, \sigma_{y,j}^i\right\}\right)$ in order to take into account also the uncertainties in the localization. With this consideration in mind, the agent's cell is given by:
        \begin{equation}
            \hat{\mathcal{V}_i}=\left\{\tilde{\mathcal{V}_i} \cap \bar{\mathcal{C}}_{i, \tilde{R_s}} \right\}
        \end{equation}
    where $\bar{\mathcal{C}}_{i, \tilde{R_s}}$ is the closure of the circle with radius $\tilde{R_s}$.  
    
    \subsubsection{Extension to the 3D case}  
    It is assumed that the agent performing the tessellation is able to detect the presence of the others even when they are above and below it in a range defined by $R_{cv}$ (sensing range in the vertical direction). In particular, when another agent is detected within this range it is included in the neighbour set as:
    \begin{gather}
        \tilde{\mathcal{N}_i} = \{p_j \in \mathcal{N_i} \lvert \lvert \Delta_z \lvert < R_{cv} + \kappa \sigma_z^i
        + \frac{\Delta_z}{\lVert \Delta_z \lVert }\Delta s_z\} %\notag
        \label{eq:neighbour_set_voronoi}
    \end{gather}
    where $\Delta_z=z_i - z_j$ is the height difference, $\Delta s_z = s_{z, i} - s_{z,j}$ is the difference between the maximum vertical displacements, and $\sigma_z^i=\sigma_{z,i}^i + \sigma_{z, j}^i$.\\
    Since the parachute models have only a unidirectional actuation in the vertical direction (i.e. they can only brake their fall and not go upwards) then the only limit that is necessary to identify for the z-axis tessellation is the lower. This can be done by:
    \begin{equation}
    {\scriptsize
        \mathcal{Z}_i = 
        \begin{cases}
            \left\{q\in \mathcal{Q} \lvert 0 \le z_i-z_q \le \Delta z - \delta_z - \kappa \sigma_z^i \right\}& \Delta_z \ge 0 \wedge i \in \tilde{\mathcal{N}_i} \\
            \left\{q \in \mathcal{Q} \lvert 0 \le z_i-z_q
            \le R_{sv} + \kappa \sigma_{z, i}^i \right\} & otherwise
        \end{cases}   } 
    \end{equation}
    where $z_q$ is the generic point along the z-axis.
   
\subsection{High-level motion control}\label{sec:details_high_level}
\subsubsection{Weights for the LQR}
The only parameters to be set in the LQR control are the weight matrices $S$ and $R$. By increasing the state matrix the algorithm tries to reduce the error between the actual state and the desired one, while by increasing the input matrix the input is minimized. They are usually competing objectives. Since the parachute inputs will be saturated in the low level control, there is no interest in using a big input matrix, while is important to have a good performance of the states to reduce the final distance between the global centroid and the target.
\subsubsection{Same control for all the chutes}
As said before this is the simples control low because the agents applys on itself the same input computed for the fake parachute representing the global centroid.
\subsubsection{Inverse kinematics}
 Regarding the inverse kinematics, in the postural task it is asks to make the single agents converge towards the global centroid, in order to reduce the root mean square of the agents distance from the global centroid end, eventually, from the target, thanks to the main task. The importance of this choice is explain further in the Results section.  When using the postural task, the weighting value is set such that the more the global centroid is close to the target, the more importance is given to letting the single parachute converge toward the global centroid, with an exponential behaviour. The pseudo-code of the inverse kinematics algorithm is presented in the Algorithm \ref{algorithm}.\\
\textcolor{red}{Decommentare l'algoritmo}
% \begin{algorithm}[hb]
% \caption{Numerical IK}\label{NIK}
%     \begin{itemize}
%     \item Find centroid error position $e_c$
%     \item Find parachute error position $e_x$
%     \item Find total error position $e=[e_c;e_x]$
%     \item Find jacobian matrix $J$
%     \item Initialize line search factor $\alpha=1$
%     \item Initialize weighting factor $w$
%     \end{itemize}
%     \mywhile \ $|e_c|^2 \ge 0.5 \And |e_x|^2 \ge 0.1$
%     \begin{enumerate}
%         \item $\Delta x = (J^TJ+w^2I)^{-1}(J^Te_c+w^2e_x)$
%         \item $x_{test} = x + \alpha \Delta x$
%         \item $x = x_{test}$
%         \item $e = e'$
%     \end{enumerate}
%     \myendwhile
%     \label{algorithm}
% \end{algorithm}

\subsubsection{Managing of emergency case}
\textcolor{blue}{
As said before, the low level control is performed after having divided the plane where the parachute moves with a voronoi tessellation considering all the agents that are in a sorrounding space of the considered one. Even though it is in principle admissible for two agents having the same psition in the xy plane and different heigh, there are some situations in which this can create problems. For example, when an agent sees many others around it, its voronoi cell may be reduced to a point because having considered uncertinities and finite dimensions. If in this case it localize other agents below it with a xy location reasonably close to its own, then it will be not able to move to avoid the collision. To solve this issue, the \textit{emergency control} tries to move the falling agent as far as possible from the new see ones. This is done by not considering the uncertinties in the tessellation (i.e. enlarging the voronoi cell as much as possible) and moving in the opposite directions with respect to sum of the vectors connecting itself and the considered ones.}
\subsection{Low-level motion control}
While the value of the LQR gain is calculated by the algorithm, the values of the proportional gains of the low-level control have to be chosen. For the linear model gain of the equation (\ref{eq:proportional}) it is important to choose a value such that there is no risk of overshooting the target. This condition is avoided if the inequality (\ref{gain}) holds: in one step the displacement given by the controller must not be greater than the target distance.\\
\begin{equation}
  k_p\left(p_i - C_{\mathcal{V}_i}\right)dt \le \left(p_i - C_{\mathcal{V}_i}\right) \Rightarrow k_p \le 1/dt
  \label{gain}
\end{equation}
For what concerns the non-linear model, on the other hand, the gain for the forward velocity is set to one and the gain for the angular velocity is set such that in one time step it is less than the maximum one (\ref{angular_vel}).
\begin{equation}
  \label{angular_vel}
  k_{\omega} = \omega_{max}/\pi
\end{equation}
\textcolor{blue}{Once the input are calculated and error is sum to them in order to take into account their errors, and the they are saturated to consider the real performances. Even tough the real actuator has not been identified the errors' standard deviation of the actuators are set as 10\% of the maximum admissible input, with a coverage factor of 3 (i.e. 99.73\% of probability).}

\subsection{Conclusion of the simulation}
When an agent touches the ground it cannot move any more, and its control input is set to zero. However, the GPS signal continues to arrive and the parachute continues to communicate with the other agents and to send its own position.